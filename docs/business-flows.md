# API BB Extrato - Fluxos de Neg√≥cio e Regras

## üìã Vis√£o Geral

Este documento detalha os **fluxos de neg√≥cio** e **regras implementadas** no sistema API BB Extrato. O sistema automatiza a consulta de extratos banc√°rios do Banco do Brasil e a reconcilia√ß√£o dos dados para controle financeiro da UFRJ/Coppetec.

## üéØ Objetivo do Neg√≥cio

**Automatizar completamente** o processo de:
1. **Consulta peri√≥dica** de extratos banc√°rios via API oficial do BB
2. **Reconcilia√ß√£o** dos dados financeiros com sistema interno
3. **Auditoria completa** de todas as opera√ß√µes
4. **Notifica√ß√£o autom√°tica** de problemas e exce√ß√µes

## üîÑ Fluxo Principal - Consulta Automatizada

### üìÖ Agendamento e Execu√ß√£o

```mermaid
graph TD
    Start([Cron Job Inicia]) --> Lock{Job j√° em<br>execu√ß√£o?}
    Lock -->|Sim| End1([Finaliza - Evita concorr√™ncia])
    Lock -->|N√£o| SetFlag[isRunning = true]
    
    SetFlag --> GetAccounts[Buscar contas ativas<br>getContaAConsultar()]
    GetAccounts --> CheckAccounts{Contas<br>encontradas?}
    
    CheckAccounts -->|N√£o| LogNoAccounts[Log: Nenhuma conta ativa]
    CheckAccounts -->|Sim| ProcessLoop[Processar cada conta]
    
    ProcessLoop --> ProcessAccount[Processar Conta Individual]
    ProcessAccount --> MoreAccounts{Mais contas<br>na lista?}
    
    MoreAccounts -->|Sim| ProcessLoop
    MoreAccounts -->|N√£o| CleanUp[isRunning = false]
    
    LogNoAccounts --> CleanUp
    CleanUp --> End2([Job Finalizado])
    
    style SetFlag fill:#e1f5fe
    style ProcessAccount fill:#fff3e0
    style CleanUp fill:#f3e5f5
```

**Configura√ß√£o do Agendamento:**
- **Express√£o Cron**: Configur√°vel via `schedule.cron` no YAML
- **Controle de Concorr√™ncia**: Flag `isRunning` impede execu√ß√µes simult√¢neas
- **Logging Detalhado**: Cada etapa √© auditada com timestamps

### üè¶ Processamento Individual de Conta

```mermaid
sequenceDiagram
    participant Job as ConsultaExtratoJob
    participant Service as BankStatementRetrievalService
    participant BB as Banco do Brasil API
    participant DB as Database
    participant Email as EmailService
    
    Job->>Service: retrieveFullStatement(account)
    Note over Service: 1. Autentica√ß√£o
    Service->>BB: auth() - OAuth2 Client Credentials
    BB-->>Service: access_token + expires_in
    
    Note over Service: 2. Consulta Paginada
    loop Para cada p√°gina
        Service->>BB: consultBankStatement(token, page)
        BB-->>Service: BankStatementResponseDto
        Note over Service: Agrega transa√ß√µes
    end
    
    Note over Service: 3. Persist√™ncia Transacional
    Service->>DB: Salvar importa√ß√£o + movimentos
    Service-->>Job: BankStatementResponseDto | null
    
    Job->>Service: persist(account, response)
    Service->>DB: Transa√ß√£o ACID completa
    
    alt Sucesso
        Job->>Job: Log sucesso
    else Erro 404 (Conta sem lan√ßamentos)
        Job->>DB: Log erro 404
        Job->>Email: Notificar conta n√£o encontrada
    else Erro 500 (Erro interno BB)
        Job->>DB: Log erro 500
        Job->>Email: Notificar erro interno
    else Retry Limit Exceeded
        Job->>DB: Log erro 999
        Job->>Email: Notificar limite excedido
    else Erro Gen√©rico
        Job->>DB: Log erro 0
        Job->>Email: Notificar erro desconhecido
    end
```

## üí∞ Fluxo de Reconcilia√ß√£o Banc√°ria

### üìä Processo de Importa√ß√£o

```mermaid
graph TD
    Start([Dados do BB Recebidos]) --> CreateImport[Criar registro<br>BankReconciliationImportEntity]
    
    CreateImport --> SetMetadata[Definir metadados da importa√ß√£o]
    SetMetadata --> SaveImport[Salvar importa√ß√£o no DB]
    
    SaveImport --> CheckTransactions{Transa√ß√µes<br>encontradas?}
    
    CheckTransactions -->|N√£o| LogEmpty[Log: Nenhuma transa√ß√£o]
    CheckTransactions -->|Sim| ProcessTransactions[Processar cada transa√ß√£o]
    
    ProcessTransactions --> ValidateDate[Validar data da transa√ß√£o]
    ValidateDate --> DateValid{Data dentro<br>do per√≠odo?}
    
    DateValid -->|N√£o| RejectTransaction[Rejeitar transa√ß√£o]
    DateValid -->|Sim| CreateMovement[Criar BankReconciliationMovementEntity]
    
    RejectTransaction --> EmailRule[Email: Regra de neg√≥cio violada]
    CreateMovement --> NextTransaction{Pr√≥xima<br>transa√ß√£o?}
    
    EmailRule --> NextTransaction
    NextTransaction -->|Sim| ProcessTransactions
    NextTransaction -->|N√£o| BulkSave[Salvar todas as movimenta√ß√µes]
    
    LogEmpty --> Commit[Commit da transa√ß√£o]
    BulkSave --> Commit
    Commit --> End([Reconcilia√ß√£o Completa])
    
    style CreateImport fill:#e8f5e8
    style ValidateDate fill:#fff3e0
    style RejectTransaction fill:#ffebee
    style BulkSave fill:#e3f2fd
```

### üìã Metadados da Importa√ß√£o

```kotlin
// Exemplo de registro de importa√ß√£o
BankReconciliationImportEntity(
    layoutId = 2,                    // Layout padr√£o do sistema
    sourceBank = "001",              // C√≥digo do Banco do Brasil
    fileName = "IMPORTED WITH API",  // Identificador da fonte
    fileGeneratedAt = LocalDateTime.now(),
    batchCount = 1,                  // Lote √∫nico por importa√ß√£o
    recordCount = transactions.size, // Total de transa√ß√µes
    accountCount = 1,                // Uma conta por importa√ß√£o
    queryAgency = account.branch,    // Ag√™ncia consultada
    queryAccount = account.currentAccount, // Conta consultada
    queryPeriodFrom = periodStart,   // In√≠cio do per√≠odo
    queryPeriodTo = periodEnd        // Fim do per√≠odo
)
```

## üõ°Ô∏è Regras de Valida√ß√£o e Neg√≥cio

### üìÖ Valida√ß√£o de Per√≠odo

**Regra Principal**: Transa√ß√µes s√≥ s√£o aceitas se estiverem dentro do per√≠odo configurado para a conta.

```kotlin
fun isTransactionDateBeforeOrEqualTo(
    transactionDate: LocalDateTime, 
    databaseDate: LocalDateTime
): Boolean {
    return transactionDate.toLocalDate().isBefore(databaseDate.toLocalDate()) ||
           transactionDate.toLocalDate().isEqual(databaseDate.toLocalDate())
}
```

**Consequ√™ncias da Viola√ß√£o**:
- Transa√ß√£o √© **rejeitada** e n√£o persistida
- Email de notifica√ß√£o √© enviado para a equipe
- Log de auditoria √© registrado com detalhes

### üè¶ Valida√ß√£o de Conta

**Regras de Conta**:
- Conta deve estar **ativa** no sistema
- Ag√™ncia e conta devem ter formato v√°lido
- Per√≠odo de consulta deve estar configurado

**Valida√ß√µes Autom√°ticas**:
```kotlin
// Valida√ß√£o de formato de ag√™ncia (ex: 2234-9)
fun validateAgencyFormat(agency: String): Boolean {
    return agency.matches(Regex("\\d{4}-\\d"))
}

// Valida√ß√£o de formato de conta (ex: 57446-5)
fun validateAccountFormat(account: String): Boolean {
    return account.matches(Regex("\\d{5}-\\d"))
}
```

## üîÑ Padr√µes de Tratamento de Erros

### üìä Categoriza√ß√£o de Erros

| C√≥digo | Tipo | Descri√ß√£o | A√ß√£o |
|--------|------|-----------|------|
| 0 | Gen√©rico | Erro desconhecido | Email + Log |
| 404 | Not Found | Conta n√£o encontrada | Email + Log |
| 500 | Internal Error | Erro interno BB | Email + Log |
| 999 | Retry Limit | Limite de tentativas | Email + Log |

### üö® Notifica√ß√µes Autom√°ticas

**Template de Email para Regras Violadas**:
```kotlin
val message = """
    Regra de neg√≥cio violada para a conta:
    Ag√™ncia: ${account.branch}
    Conta: ${account.currentAccount}
    
    Transa√ß√£o: ${transactionDate}
    Per√≠odo Configurado: ${databaseDate}
    
    A transa√ß√£o foi rejeitada automaticamente.
""".trimIndent()
```

**Template de Email para Erros de Persist√™ncia**:
```kotlin
val message = """
    Erro durante persist√™ncia para:
    Ag√™ncia: ${account.branch}
    Conta: ${account.currentAccount}
    
    Erro: ${errorMessage}
    Timestamp: ${LocalDateTime.now()}
    
    Verificar logs do sistema.
""".trimIndent()
```

## üìà Monitoramento e M√©tricas

### üéØ M√©tricas de Performance

**Tempo de Execu√ß√£o**:
- **M√°ximo Aceit√°vel**: 1 segundo para workflow completo
- **Varia√ß√£o M√°xima**: 100ms entre execu√ß√µes consecutivas
- **Throughput M√≠nimo**: 5 requisi√ß√µes por segundo

**M√©tricas de Job**:
```kotlin
data class JobProgressSummaryResponse(
    val activeJobs: Int,           // Jobs em execu√ß√£o
    val completedJobs: Int,        // Jobs conclu√≠dos
    val failedJobs: Int,           // Jobs falharam
    val cancelledJobs: Int,        // Jobs cancelados
    val averageExecutionTime: Double, // Tempo m√©dio de execu√ß√£o
    val successRate: Double,       // Taxa de sucesso (%)
    val totalRecordsProcessed: Long, // Total de registros processados
    val totalAccountsProcessed: Int  // Total de contas processadas
)
```

### üìä Logs de Auditoria

**Estrutura do Log**:
```kotlin
ConsultaContaCorrenteExtratoLogEntity(
    agencia = account.branch,
    contaCorrente = account.currentAccount,
    dataInicio = account.queryPeriodFrom,
    dataFim = account.queryPeriodTo,
    status = executionStatus,
    mensagem = detailedMessage,
    timestamp = LocalDateTime.now()
)
```

**N√≠veis de Log**:
- **INFO**: Opera√ß√µes normais e sucessos
- **WARN**: Situa√ß√µes que merecem aten√ß√£o
- **ERROR**: Erros que impedem execu√ß√£o
- **DEBUG**: Detalhes para troubleshooting

## üîß Padr√µes T√©cnicos Implementados

### üèóÔ∏è Arquitetura de Camadas

**1. Domain Layer (Regras de Neg√≥cio)**:
- Entidades puras sem depend√™ncias externas
- Valida√ß√µes de regras de neg√≥cio
- Exceptions espec√≠ficas do dom√≠nio

**2. Application Layer (Casos de Uso)**:
- Services que orquestram opera√ß√µes
- Ports que definem contratos
- DTOs para transfer√™ncia de dados

**3. Infrastructure Layer (Adaptadores)**:
- Implementa√ß√µes de reposit√≥rios
- Clientes HTTP para APIs externas
- Jobs agendados e configura√ß√µes

### üîÑ Padr√µes de Design

**1. Repository Pattern**:
```kotlin
interface AccountPort {
    fun getAllActiveAccounts(): List<Account>
    fun save(account: Account): Account
}
```

**2. Template Method Pattern**:
```kotlin
// Processamento padronizado de contas
private fun processarContas(jobName: String) {
    val accounts = accountPort.getAllActiveAccounts()
    accounts.forEachIndexed { index, account ->
        processarContaIndividual(account, index, accounts.size, jobName)
    }
}
```

**3. Observer Pattern**:
```kotlin
// Notifica√ß√µes autom√°ticas em eventos
emailService.send(
    account = account,
    message = message,
    error = error
)
```

**4. Retry Pattern**:
```kotlin
// Configura√ß√£o de retry via Resilience4j
@Retry(name = "bb-api-retry")
@CircuitBreaker(name = "bb-api-circuit-breaker")
fun consultBankStatement(request: BankStatementRequest): BankStatementResponseDto
```

## üöÄ Otimiza√ß√µes de Performance

### üìä Processamento em Lote

**Bulk Operations**:
```kotlin
// Salvamento em lote de movimenta√ß√µes
bankReconciliationMovementPort.saveAll(movements)
```

**Transa√ß√µes Otimizadas**:
```kotlin
@Transactional(rollbackOn = [Exception::class])
fun persist(account: Account, response: BankStatementResponseDto?) {
    // Toda opera√ß√£o em uma √∫nica transa√ß√£o
    // Rollback autom√°tico em caso de erro
}
```

### üîÑ Pagina√ß√£o Inteligente

**Consulta Paginada**:
```kotlin
var currentPage = 0
do {
    val response = bbPort.consultBankStatement(request.copy(pageNumber = currentPage.toString()))
    bankStatement.transactions.addAll(response.transactions)
    currentPage = response.nextPageNumber
} while (currentPage != 0)
```

**Agrega√ß√£o de Resultados**:
- Transa√ß√µes s√£o agregadas em mem√≥ria
- Uma √∫nica transa√ß√£o de banco para persist√™ncia
- Redu√ß√£o de overhead de rede e banco

## üìã Configura√ß√µes e Propriedades

### ‚öôÔ∏è Configura√ß√µes de Agendamento

```yaml
schedule:
  cron: "0 0 6 * * ?"  # 6h da manh√£, todos os dias
  max-concurrent-jobs: 1
  retry-attempts: 3
  retry-delay: 5000ms
```

### üîê Configura√ß√µes de Seguran√ßa

**OAuth2 Client Credentials**:
```yaml
bb:
  api:
    client-id: ${BB_CLIENT_ID}
    client-secret: ${BB_CLIENT_SECRET}
    scope: "extrato.read"
    token-url: "https://oauth.bb.com.br/oauth/token"
```

**SSL/TLS**:
```yaml
feign:
  client:
    config:
      default:
        connectTimeout: 5000
        readTimeout: 10000
        loggerLevel: BASIC
```

## üéØ Pr√≥ximos Passos e Melhorias

### üìä M√©tricas Avan√ßadas

**Implementar**:
- Dashboard de m√©tricas em tempo real
- Alertas autom√°ticos para falhas
- Hist√≥rico de performance por per√≠odo

### üîÑ Resili√™ncia

**Melhorar**:
- Circuit breaker mais sofisticado
- Fallback strategies para APIs externas
- Dead letter queue para mensagens falhadas

### üìà Escalabilidade

**Considerar**:
- Processamento paralelo de contas
- Cache distribu√≠do para tokens
- Load balancing para m√∫ltiplas inst√¢ncias

---

**Documento Atualizado**: ${LocalDateTime.now().format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss"))}
**Vers√£o**: 2.0 - Padr√µes T√©cnicos e Fluxos Completos
